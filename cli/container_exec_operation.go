// Code generated by go-swagger; DO NOT EDIT.

package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"

	"github.com/go-swagger/dockerctl/client/exec"

	"github.com/go-openapi/swag"
	"github.com/spf13/cobra"
)

// makeOperationExecContainerExecCmd returns a cmd to handle operation containerExec
func makeOperationExecContainerExecCmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use:   "ContainerExec",
		Short: `Run a command inside a running container.`,
		RunE:  runOperationExecContainerExec,
	}

	if err := registerOperationExecContainerExecParamFlags(cmd); err != nil {
		return nil, err
	}

	return cmd, nil
}

// runOperationExecContainerExec uses cmd flags to call endpoint api
func runOperationExecContainerExec(cmd *cobra.Command, args []string) error {
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := exec.NewContainerExecParams()
	if err, _ := retrieveOperationExecContainerExecExecConfigFlag(params, "", cmd); err != nil {
		return err
	}
	if err, _ := retrieveOperationExecContainerExecIDFlag(params, "", cmd); err != nil {
		return err
	}
	if dryRun {

		logDebugf("dry-run flag specified. Skip sending request.")
		return nil
	}
	// make request and then print result
	msgStr, err := parseOperationExecContainerExecResult(appCli.Exec.ContainerExec(params))
	if err != nil {
		return err
	}
	if !debug {

		fmt.Println(msgStr)
	}
	return nil
}

// registerOperationExecContainerExecParamFlags registers all flags needed to fill params
func registerOperationExecContainerExecParamFlags(cmd *cobra.Command) error {
	if err := registerOperationExecContainerExecExecConfigParamFlags("", cmd); err != nil {
		return err
	}
	if err := registerOperationExecContainerExecIDParamFlags("", cmd); err != nil {
		return err
	}
	return nil
}

func registerOperationExecContainerExecExecConfigParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	var ExecConfigFlagName string
	if cmdPrefix == "" {
		ExecConfigFlagName = "execConfig"
	} else {
		ExecConfigFlagName = fmt.Sprintf("%v.execConfig", cmdPrefix)
	}

	_ = cmd.PersistentFlags().String(ExecConfigFlagName, "", "Optional json string for [execConfig]. Exec configuration")

	// add flags for body
	if err := registerModelContainerExecBodyFlags(0, "containerExecBody", cmd); err != nil {
		return err
	}

	return nil
}
func registerOperationExecContainerExecIDParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	IDDescription := `Required. ID or name of container`

	var IDFlagName string
	if cmdPrefix == "" {
		IDFlagName = "id"
	} else {
		IDFlagName = fmt.Sprintf("%v.id", cmdPrefix)
	}

	var IDFlagDefault string

	_ = cmd.PersistentFlags().String(IDFlagName, IDFlagDefault, IDDescription)

	return nil
}

func retrieveOperationExecContainerExecExecConfigFlag(m *exec.ContainerExecParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("execConfig") {
		// Read execConfig string from cmd and unmarshal
		execConfigValueStr, err := cmd.Flags().GetString("execConfig")
		if err != nil {
			return err, false
		}

		execConfigValue := exec.ContainerExecBody{}
		if err := json.Unmarshal([]byte(execConfigValueStr), &execConfigValue); err != nil {
			return fmt.Errorf("cannot unmarshal execConfig string in ContainerExecBody: %v", err), false
		}
		m.ExecConfig = execConfigValue
	}
	execConfigValueModel := m.ExecConfig
	if swag.IsZero(execConfigValueModel) {
		execConfigValueModel = exec.ContainerExecBody{}
	}
	err, added := retrieveModelContainerExecBodyFlags(0, &execConfigValueModel, "containerExecBody", cmd)
	if err != nil {
		return err, false
	}
	if added {
		m.ExecConfig = execConfigValueModel
	}
	if dryRun && debug {

		execConfigValueDebugBytes, err := json.Marshal(m.ExecConfig)
		if err != nil {
			return err, false
		}
		logDebugf("ExecConfig dry-run payload: %v", string(execConfigValueDebugBytes))
	}
	retAdded = retAdded || added

	return nil, retAdded
}
func retrieveOperationExecContainerExecIDFlag(m *exec.ContainerExecParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("id") {

		var IDFlagName string
		if cmdPrefix == "" {
			IDFlagName = "id"
		} else {
			IDFlagName = fmt.Sprintf("%v.id", cmdPrefix)
		}

		IDFlagValue, err := cmd.Flags().GetString(IDFlagName)
		if err != nil {
			return err, false
		}
		m.ID = IDFlagValue

	}
	return nil, retAdded
}

// parseOperationExecContainerExecResult parses request result and return the string content
func parseOperationExecContainerExecResult(resp0 *exec.ContainerExecCreated, respErr error) (string, error) {
	if respErr != nil {

		var iResp0 interface{} = respErr
		resp0, ok := iResp0.(*exec.ContainerExecCreated)
		if ok {
			if !swag.IsZero(resp0) && !swag.IsZero(resp0.Payload) {
				msgStr, err := json.Marshal(resp0.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp1 interface{} = respErr
		resp1, ok := iResp1.(*exec.ContainerExecNotFound)
		if ok {
			if !swag.IsZero(resp1) && !swag.IsZero(resp1.Payload) {
				msgStr, err := json.Marshal(resp1.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp2 interface{} = respErr
		resp2, ok := iResp2.(*exec.ContainerExecConflict)
		if ok {
			if !swag.IsZero(resp2) && !swag.IsZero(resp2.Payload) {
				msgStr, err := json.Marshal(resp2.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp3 interface{} = respErr
		resp3, ok := iResp3.(*exec.ContainerExecInternalServerError)
		if ok {
			if !swag.IsZero(resp3) && !swag.IsZero(resp3.Payload) {
				msgStr, err := json.Marshal(resp3.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		return "", respErr
	}

	if !swag.IsZero(resp0) && !swag.IsZero(resp0.Payload) {
		msgStr, err := json.Marshal(resp0.Payload)
		if err != nil {
			return "", err
		}
		return string(msgStr), nil
	}

	return "", nil
}

// register flags to command
func registerModelContainerExecBodyFlags(depth int, cmdPrefix string, cmd *cobra.Command) error {

	if err := registerContainerExecBodyAttachStderr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyAttachStdin(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyAttachStdout(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyCmd(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyDetachKeys(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyEnv(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyPrivileged(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyTty(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyUser(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerContainerExecBodyWorkingDir(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	return nil
}

func registerContainerExecBodyAttachStderr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	AttachStderrDescription := `Attach to ` + "`" + `stderr` + "`" + ` of the exec command.`

	var AttachStderrFlagName string
	if cmdPrefix == "" {
		AttachStderrFlagName = "AttachStderr"
	} else {
		AttachStderrFlagName = fmt.Sprintf("%v.AttachStderr", cmdPrefix)
	}

	var AttachStderrFlagDefault bool

	_ = cmd.PersistentFlags().Bool(AttachStderrFlagName, AttachStderrFlagDefault, AttachStderrDescription)

	return nil
}

func registerContainerExecBodyAttachStdin(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	AttachStdinDescription := `Attach to ` + "`" + `stdin` + "`" + ` of the exec command.`

	var AttachStdinFlagName string
	if cmdPrefix == "" {
		AttachStdinFlagName = "AttachStdin"
	} else {
		AttachStdinFlagName = fmt.Sprintf("%v.AttachStdin", cmdPrefix)
	}

	var AttachStdinFlagDefault bool

	_ = cmd.PersistentFlags().Bool(AttachStdinFlagName, AttachStdinFlagDefault, AttachStdinDescription)

	return nil
}

func registerContainerExecBodyAttachStdout(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	AttachStdoutDescription := `Attach to ` + "`" + `stdout` + "`" + ` of the exec command.`

	var AttachStdoutFlagName string
	if cmdPrefix == "" {
		AttachStdoutFlagName = "AttachStdout"
	} else {
		AttachStdoutFlagName = fmt.Sprintf("%v.AttachStdout", cmdPrefix)
	}

	var AttachStdoutFlagDefault bool

	_ = cmd.PersistentFlags().Bool(AttachStdoutFlagName, AttachStdoutFlagDefault, AttachStdoutDescription)

	return nil
}

func registerContainerExecBodyCmd(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: Cmd []string array type is not supported by go-swagger cli yet

	return nil
}

func registerContainerExecBodyDetachKeys(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	DetachKeysDescription := `Override the key sequence for detaching a container. Format is a single character ` + "`" + `[a-Z]` + "`" + ` or ` + "`" + `ctrl-<value>` + "`" + ` where ` + "`" + `<value>` + "`" + ` is one of: ` + "`" + `a-z` + "`" + `, ` + "`" + `@` + "`" + `, ` + "`" + `^` + "`" + `, ` + "`" + `[` + "`" + `, ` + "`" + `,` + "`" + ` or ` + "`" + `_` + "`" + `.`

	var DetachKeysFlagName string
	if cmdPrefix == "" {
		DetachKeysFlagName = "DetachKeys"
	} else {
		DetachKeysFlagName = fmt.Sprintf("%v.DetachKeys", cmdPrefix)
	}

	var DetachKeysFlagDefault string

	_ = cmd.PersistentFlags().String(DetachKeysFlagName, DetachKeysFlagDefault, DetachKeysDescription)

	return nil
}

func registerContainerExecBodyEnv(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: Env []string array type is not supported by go-swagger cli yet

	return nil
}

func registerContainerExecBodyPrivileged(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	PrivilegedDescription := `Runs the exec process with extended privileges.`

	var PrivilegedFlagName string
	if cmdPrefix == "" {
		PrivilegedFlagName = "Privileged"
	} else {
		PrivilegedFlagName = fmt.Sprintf("%v.Privileged", cmdPrefix)
	}

	var PrivilegedFlagDefault bool

	_ = cmd.PersistentFlags().Bool(PrivilegedFlagName, PrivilegedFlagDefault, PrivilegedDescription)

	return nil
}

func registerContainerExecBodyTty(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	TtyDescription := `Allocate a pseudo-TTY.`

	var TtyFlagName string
	if cmdPrefix == "" {
		TtyFlagName = "Tty"
	} else {
		TtyFlagName = fmt.Sprintf("%v.Tty", cmdPrefix)
	}

	var TtyFlagDefault bool

	_ = cmd.PersistentFlags().Bool(TtyFlagName, TtyFlagDefault, TtyDescription)

	return nil
}

func registerContainerExecBodyUser(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	UserDescription := `The user, and optionally, group to run the exec process inside the container. Format is one of: ` + "`" + `user` + "`" + `, ` + "`" + `user:group` + "`" + `, ` + "`" + `uid` + "`" + `, or ` + "`" + `uid:gid` + "`" + `.`

	var UserFlagName string
	if cmdPrefix == "" {
		UserFlagName = "User"
	} else {
		UserFlagName = fmt.Sprintf("%v.User", cmdPrefix)
	}

	var UserFlagDefault string

	_ = cmd.PersistentFlags().String(UserFlagName, UserFlagDefault, UserDescription)

	return nil
}

func registerContainerExecBodyWorkingDir(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	WorkingDirDescription := `The working directory for the exec process inside the container.`

	var WorkingDirFlagName string
	if cmdPrefix == "" {
		WorkingDirFlagName = "WorkingDir"
	} else {
		WorkingDirFlagName = fmt.Sprintf("%v.WorkingDir", cmdPrefix)
	}

	var WorkingDirFlagDefault string

	_ = cmd.PersistentFlags().String(WorkingDirFlagName, WorkingDirFlagDefault, WorkingDirDescription)

	return nil
}

// retrieve flags from commands, and set value in model. Return true if any flag is passed by user to fill model field.
func retrieveModelContainerExecBodyFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false

	err, AttachStderrAdded := retrieveContainerExecBodyAttachStderrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || AttachStderrAdded

	err, AttachStdinAdded := retrieveContainerExecBodyAttachStdinFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || AttachStdinAdded

	err, AttachStdoutAdded := retrieveContainerExecBodyAttachStdoutFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || AttachStdoutAdded

	err, CmdAdded := retrieveContainerExecBodyCmdFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || CmdAdded

	err, DetachKeysAdded := retrieveContainerExecBodyDetachKeysFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || DetachKeysAdded

	err, EnvAdded := retrieveContainerExecBodyEnvFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || EnvAdded

	err, PrivilegedAdded := retrieveContainerExecBodyPrivilegedFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || PrivilegedAdded

	err, TtyAdded := retrieveContainerExecBodyTtyFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || TtyAdded

	err, UserAdded := retrieveContainerExecBodyUserFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || UserAdded

	err, WorkingDirAdded := retrieveContainerExecBodyWorkingDirFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || WorkingDirAdded

	return nil, retAdded
}

func retrieveContainerExecBodyAttachStderrFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	AttachStderrFlagName := fmt.Sprintf("%v.AttachStderr", cmdPrefix)
	if cmd.Flags().Changed(AttachStderrFlagName) {

		var AttachStderrFlagName string
		if cmdPrefix == "" {
			AttachStderrFlagName = "AttachStderr"
		} else {
			AttachStderrFlagName = fmt.Sprintf("%v.AttachStderr", cmdPrefix)
		}

		AttachStderrFlagValue, err := cmd.Flags().GetBool(AttachStderrFlagName)
		if err != nil {
			return err, false
		}
		m.AttachStderr = AttachStderrFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyAttachStdinFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	AttachStdinFlagName := fmt.Sprintf("%v.AttachStdin", cmdPrefix)
	if cmd.Flags().Changed(AttachStdinFlagName) {

		var AttachStdinFlagName string
		if cmdPrefix == "" {
			AttachStdinFlagName = "AttachStdin"
		} else {
			AttachStdinFlagName = fmt.Sprintf("%v.AttachStdin", cmdPrefix)
		}

		AttachStdinFlagValue, err := cmd.Flags().GetBool(AttachStdinFlagName)
		if err != nil {
			return err, false
		}
		m.AttachStdin = AttachStdinFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyAttachStdoutFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	AttachStdoutFlagName := fmt.Sprintf("%v.AttachStdout", cmdPrefix)
	if cmd.Flags().Changed(AttachStdoutFlagName) {

		var AttachStdoutFlagName string
		if cmdPrefix == "" {
			AttachStdoutFlagName = "AttachStdout"
		} else {
			AttachStdoutFlagName = fmt.Sprintf("%v.AttachStdout", cmdPrefix)
		}

		AttachStdoutFlagValue, err := cmd.Flags().GetBool(AttachStdoutFlagName)
		if err != nil {
			return err, false
		}
		m.AttachStdout = AttachStdoutFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyCmdFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	CmdFlagName := fmt.Sprintf("%v.Cmd", cmdPrefix)
	if cmd.Flags().Changed(CmdFlagName) {
		// warning: Cmd array type []string is not supported by go-swagger cli yet
	}

	return nil, retAdded
}

func retrieveContainerExecBodyDetachKeysFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	DetachKeysFlagName := fmt.Sprintf("%v.DetachKeys", cmdPrefix)
	if cmd.Flags().Changed(DetachKeysFlagName) {

		var DetachKeysFlagName string
		if cmdPrefix == "" {
			DetachKeysFlagName = "DetachKeys"
		} else {
			DetachKeysFlagName = fmt.Sprintf("%v.DetachKeys", cmdPrefix)
		}

		DetachKeysFlagValue, err := cmd.Flags().GetString(DetachKeysFlagName)
		if err != nil {
			return err, false
		}
		m.DetachKeys = DetachKeysFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyEnvFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	EnvFlagName := fmt.Sprintf("%v.Env", cmdPrefix)
	if cmd.Flags().Changed(EnvFlagName) {
		// warning: Env array type []string is not supported by go-swagger cli yet
	}

	return nil, retAdded
}

func retrieveContainerExecBodyPrivilegedFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	PrivilegedFlagName := fmt.Sprintf("%v.Privileged", cmdPrefix)
	if cmd.Flags().Changed(PrivilegedFlagName) {

		var PrivilegedFlagName string
		if cmdPrefix == "" {
			PrivilegedFlagName = "Privileged"
		} else {
			PrivilegedFlagName = fmt.Sprintf("%v.Privileged", cmdPrefix)
		}

		PrivilegedFlagValue, err := cmd.Flags().GetBool(PrivilegedFlagName)
		if err != nil {
			return err, false
		}
		m.Privileged = &PrivilegedFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyTtyFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	TtyFlagName := fmt.Sprintf("%v.Tty", cmdPrefix)
	if cmd.Flags().Changed(TtyFlagName) {

		var TtyFlagName string
		if cmdPrefix == "" {
			TtyFlagName = "Tty"
		} else {
			TtyFlagName = fmt.Sprintf("%v.Tty", cmdPrefix)
		}

		TtyFlagValue, err := cmd.Flags().GetBool(TtyFlagName)
		if err != nil {
			return err, false
		}
		m.Tty = TtyFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyUserFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	UserFlagName := fmt.Sprintf("%v.User", cmdPrefix)
	if cmd.Flags().Changed(UserFlagName) {

		var UserFlagName string
		if cmdPrefix == "" {
			UserFlagName = "User"
		} else {
			UserFlagName = fmt.Sprintf("%v.User", cmdPrefix)
		}

		UserFlagValue, err := cmd.Flags().GetString(UserFlagName)
		if err != nil {
			return err, false
		}
		m.User = UserFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveContainerExecBodyWorkingDirFlags(depth int, m *exec.ContainerExecBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	WorkingDirFlagName := fmt.Sprintf("%v.WorkingDir", cmdPrefix)
	if cmd.Flags().Changed(WorkingDirFlagName) {

		var WorkingDirFlagName string
		if cmdPrefix == "" {
			WorkingDirFlagName = "WorkingDir"
		} else {
			WorkingDirFlagName = fmt.Sprintf("%v.WorkingDir", cmdPrefix)
		}

		WorkingDirFlagValue, err := cmd.Flags().GetString(WorkingDirFlagName)
		if err != nil {
			return err, false
		}
		m.WorkingDir = WorkingDirFlagValue

		retAdded = true
	}

	return nil, retAdded
}
