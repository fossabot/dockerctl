// Code generated by go-swagger; DO NOT EDIT.

package cli

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"fmt"

	"github.com/go-swagger/dockerctl/client/swarm"
	"github.com/go-swagger/dockerctl/models"

	"github.com/go-openapi/swag"
	"github.com/spf13/cobra"
)

// makeOperationSwarmSwarmInitCmd returns a cmd to handle operation swarmInit
func makeOperationSwarmSwarmInitCmd() (*cobra.Command, error) {
	cmd := &cobra.Command{
		Use:   "SwarmInit",
		Short: ``,
		RunE:  runOperationSwarmSwarmInit,
	}

	if err := registerOperationSwarmSwarmInitParamFlags(cmd); err != nil {
		return nil, err
	}

	return cmd, nil
}

// runOperationSwarmSwarmInit uses cmd flags to call endpoint api
func runOperationSwarmSwarmInit(cmd *cobra.Command, args []string) error {
	appCli, err := makeClient(cmd, args)
	if err != nil {
		return err
	}
	// retrieve flag values from cmd and fill params
	params := swarm.NewSwarmInitParams()
	if err, _ := retrieveOperationSwarmSwarmInitBodyFlag(params, "", cmd); err != nil {
		return err
	}
	if dryRun {

		logDebugf("dry-run flag specified. Skip sending request.")
		return nil
	}
	// make request and then print result
	msgStr, err := parseOperationSwarmSwarmInitResult(appCli.Swarm.SwarmInit(params))
	if err != nil {
		return err
	}
	if !debug {

		fmt.Println(msgStr)
	}
	return nil
}

// registerOperationSwarmSwarmInitParamFlags registers all flags needed to fill params
func registerOperationSwarmSwarmInitParamFlags(cmd *cobra.Command) error {
	if err := registerOperationSwarmSwarmInitBodyParamFlags("", cmd); err != nil {
		return err
	}
	return nil
}

func registerOperationSwarmSwarmInitBodyParamFlags(cmdPrefix string, cmd *cobra.Command) error {

	var BodyFlagName string
	if cmdPrefix == "" {
		BodyFlagName = "body"
	} else {
		BodyFlagName = fmt.Sprintf("%v.body", cmdPrefix)
	}

	_ = cmd.PersistentFlags().String(BodyFlagName, "", "Optional json string for [body]. ")

	// add flags for body
	if err := registerModelSwarmInitBodyFlags(0, "swarmInitBody", cmd); err != nil {
		return err
	}

	return nil
}

func retrieveOperationSwarmSwarmInitBodyFlag(m *swarm.SwarmInitParams, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false
	if cmd.Flags().Changed("body") {
		// Read body string from cmd and unmarshal
		bodyValueStr, err := cmd.Flags().GetString("body")
		if err != nil {
			return err, false
		}

		bodyValue := swarm.SwarmInitBody{}
		if err := json.Unmarshal([]byte(bodyValueStr), &bodyValue); err != nil {
			return fmt.Errorf("cannot unmarshal body string in SwarmInitBody: %v", err), false
		}
		m.Body = bodyValue
	}
	bodyValueModel := m.Body
	if swag.IsZero(bodyValueModel) {
		bodyValueModel = swarm.SwarmInitBody{}
	}
	err, added := retrieveModelSwarmInitBodyFlags(0, &bodyValueModel, "swarmInitBody", cmd)
	if err != nil {
		return err, false
	}
	if added {
		m.Body = bodyValueModel
	}
	if dryRun && debug {

		bodyValueDebugBytes, err := json.Marshal(m.Body)
		if err != nil {
			return err, false
		}
		logDebugf("Body dry-run payload: %v", string(bodyValueDebugBytes))
	}
	retAdded = retAdded || added

	return nil, retAdded
}

// parseOperationSwarmSwarmInitResult parses request result and return the string content
func parseOperationSwarmSwarmInitResult(resp0 *swarm.SwarmInitOK, respErr error) (string, error) {
	if respErr != nil {

		var iResp0 interface{} = respErr
		resp0, ok := iResp0.(*swarm.SwarmInitOK)
		if ok {
			if !swag.IsZero(resp0) && !swag.IsZero(resp0.Payload) {
				msgStr, err := json.Marshal(resp0.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp1 interface{} = respErr
		resp1, ok := iResp1.(*swarm.SwarmInitBadRequest)
		if ok {
			if !swag.IsZero(resp1) && !swag.IsZero(resp1.Payload) {
				msgStr, err := json.Marshal(resp1.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp2 interface{} = respErr
		resp2, ok := iResp2.(*swarm.SwarmInitInternalServerError)
		if ok {
			if !swag.IsZero(resp2) && !swag.IsZero(resp2.Payload) {
				msgStr, err := json.Marshal(resp2.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		var iResp3 interface{} = respErr
		resp3, ok := iResp3.(*swarm.SwarmInitServiceUnavailable)
		if ok {
			if !swag.IsZero(resp3) && !swag.IsZero(resp3.Payload) {
				msgStr, err := json.Marshal(resp3.Payload)
				if err != nil {
					return "", err
				}
				return string(msgStr), nil
			}
		}

		return "", respErr
	}

	if !swag.IsZero(resp0) && !swag.IsZero(resp0.Payload) {
		msgStr := fmt.Sprintf("%v", resp0.Payload)
		return string(msgStr), nil
	}

	return "", nil
}

// register flags to command
func registerModelSwarmInitBodyFlags(depth int, cmdPrefix string, cmd *cobra.Command) error {

	if err := registerSwarmInitBodyAdvertiseAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyDataPathAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyDataPathPort(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyDefaultAddrPool(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyForceNewCluster(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodyListenAddr(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodySpec(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	if err := registerSwarmInitBodySubnetSize(depth, cmdPrefix, cmd); err != nil {
		return err
	}

	return nil
}

func registerSwarmInitBodyAdvertiseAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	AdvertiseAddrDescription := `Externally reachable address advertised to other nodes. This can either be an address/port combination in the form ` + "`" + `192.168.1.1:4567` + "`" + `, or an interface followed by a port number, like ` + "`" + `eth0:4567` + "`" + `. If the port number is omitted, the port number from the listen address is used. If ` + "`" + `AdvertiseAddr` + "`" + ` is not specified, it will be automatically detected when possible.`

	var AdvertiseAddrFlagName string
	if cmdPrefix == "" {
		AdvertiseAddrFlagName = "AdvertiseAddr"
	} else {
		AdvertiseAddrFlagName = fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
	}

	var AdvertiseAddrFlagDefault string

	_ = cmd.PersistentFlags().String(AdvertiseAddrFlagName, AdvertiseAddrFlagDefault, AdvertiseAddrDescription)

	return nil
}

func registerSwarmInitBodyDataPathAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	DataPathAddrDescription := `Address or interface to use for data path traffic (format: ` + "`" + `<ip|interface>` + "`" + `), for example,  ` + "`" + `192.168.1.1` + "`" + `,
or an interface, like ` + "`" + `eth0` + "`" + `. If ` + "`" + `DataPathAddr` + "`" + ` is unspecified, the same address as ` + "`" + `AdvertiseAddr` + "`" + `
is used.

The ` + "`" + `DataPathAddr` + "`" + ` specifies the address that global scope network drivers will publish towards other
nodes in order to reach the containers running on this node. Using this parameter it is possible to
separate the container data traffic from the management traffic of the cluster.
`

	var DataPathAddrFlagName string
	if cmdPrefix == "" {
		DataPathAddrFlagName = "DataPathAddr"
	} else {
		DataPathAddrFlagName = fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
	}

	var DataPathAddrFlagDefault string

	_ = cmd.PersistentFlags().String(DataPathAddrFlagName, DataPathAddrFlagDefault, DataPathAddrDescription)

	return nil
}

func registerSwarmInitBodyDataPathPort(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: primitive DataPathPort uint32 is not supported by go-swagger cli yet

	return nil
}

func registerSwarmInitBodyDefaultAddrPool(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: DefaultAddrPool []string array type is not supported by go-swagger cli yet

	return nil
}

func registerSwarmInitBodyForceNewCluster(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	ForceNewClusterDescription := `Force creation of a new swarm.`

	var ForceNewClusterFlagName string
	if cmdPrefix == "" {
		ForceNewClusterFlagName = "ForceNewCluster"
	} else {
		ForceNewClusterFlagName = fmt.Sprintf("%v.ForceNewCluster", cmdPrefix)
	}

	var ForceNewClusterFlagDefault bool

	_ = cmd.PersistentFlags().Bool(ForceNewClusterFlagName, ForceNewClusterFlagDefault, ForceNewClusterDescription)

	return nil
}

func registerSwarmInitBodyListenAddr(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	ListenAddrDescription := `Listen address used for inter-manager communication, as well as determining the networking interface used for the VXLAN Tunnel Endpoint (VTEP). This can either be an address/port combination in the form ` + "`" + `192.168.1.1:4567` + "`" + `, or an interface followed by a port number, like ` + "`" + `eth0:4567` + "`" + `. If the port number is omitted, the default swarm listening port is used.`

	var ListenAddrFlagName string
	if cmdPrefix == "" {
		ListenAddrFlagName = "ListenAddr"
	} else {
		ListenAddrFlagName = fmt.Sprintf("%v.ListenAddr", cmdPrefix)
	}

	var ListenAddrFlagDefault string

	_ = cmd.PersistentFlags().String(ListenAddrFlagName, ListenAddrFlagDefault, ListenAddrDescription)

	return nil
}

func registerSwarmInitBodySpec(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	var SpecFlagName string
	if cmdPrefix == "" {
		SpecFlagName = "Spec"
	} else {
		SpecFlagName = fmt.Sprintf("%v.Spec", cmdPrefix)
	}

	if err := registerModelSwarmSpecFlags(depth+1, SpecFlagName, cmd); err != nil {
		return err
	}

	return nil
}

func registerSwarmInitBodySubnetSize(depth int, cmdPrefix string, cmd *cobra.Command) error {
	if depth > maxDepth {
		return nil
	}

	// warning: primitive SubnetSize uint32 is not supported by go-swagger cli yet

	return nil
}

// retrieve flags from commands, and set value in model. Return true if any flag is passed by user to fill model field.
func retrieveModelSwarmInitBodyFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	retAdded := false

	err, AdvertiseAddrAdded := retrieveSwarmInitBodyAdvertiseAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || AdvertiseAddrAdded

	err, DataPathAddrAdded := retrieveSwarmInitBodyDataPathAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || DataPathAddrAdded

	err, DataPathPortAdded := retrieveSwarmInitBodyDataPathPortFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || DataPathPortAdded

	err, DefaultAddrPoolAdded := retrieveSwarmInitBodyDefaultAddrPoolFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || DefaultAddrPoolAdded

	err, ForceNewClusterAdded := retrieveSwarmInitBodyForceNewClusterFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || ForceNewClusterAdded

	err, ListenAddrAdded := retrieveSwarmInitBodyListenAddrFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || ListenAddrAdded

	err, SpecAdded := retrieveSwarmInitBodySpecFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || SpecAdded

	err, SubnetSizeAdded := retrieveSwarmInitBodySubnetSizeFlags(depth, m, cmdPrefix, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || SubnetSizeAdded

	return nil, retAdded
}

func retrieveSwarmInitBodyAdvertiseAddrFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	AdvertiseAddrFlagName := fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
	if cmd.Flags().Changed(AdvertiseAddrFlagName) {

		var AdvertiseAddrFlagName string
		if cmdPrefix == "" {
			AdvertiseAddrFlagName = "AdvertiseAddr"
		} else {
			AdvertiseAddrFlagName = fmt.Sprintf("%v.AdvertiseAddr", cmdPrefix)
		}

		AdvertiseAddrFlagValue, err := cmd.Flags().GetString(AdvertiseAddrFlagName)
		if err != nil {
			return err, false
		}
		m.AdvertiseAddr = AdvertiseAddrFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyDataPathAddrFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	DataPathAddrFlagName := fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
	if cmd.Flags().Changed(DataPathAddrFlagName) {

		var DataPathAddrFlagName string
		if cmdPrefix == "" {
			DataPathAddrFlagName = "DataPathAddr"
		} else {
			DataPathAddrFlagName = fmt.Sprintf("%v.DataPathAddr", cmdPrefix)
		}

		DataPathAddrFlagValue, err := cmd.Flags().GetString(DataPathAddrFlagName)
		if err != nil {
			return err, false
		}
		m.DataPathAddr = DataPathAddrFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyDataPathPortFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	DataPathPortFlagName := fmt.Sprintf("%v.DataPathPort", cmdPrefix)
	if cmd.Flags().Changed(DataPathPortFlagName) {

		// warning: primitive DataPathPort uint32 is not supported by go-swagger cli yet

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyDefaultAddrPoolFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	DefaultAddrPoolFlagName := fmt.Sprintf("%v.DefaultAddrPool", cmdPrefix)
	if cmd.Flags().Changed(DefaultAddrPoolFlagName) {
		// warning: DefaultAddrPool array type []string is not supported by go-swagger cli yet
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyForceNewClusterFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	ForceNewClusterFlagName := fmt.Sprintf("%v.ForceNewCluster", cmdPrefix)
	if cmd.Flags().Changed(ForceNewClusterFlagName) {

		var ForceNewClusterFlagName string
		if cmdPrefix == "" {
			ForceNewClusterFlagName = "ForceNewCluster"
		} else {
			ForceNewClusterFlagName = fmt.Sprintf("%v.ForceNewCluster", cmdPrefix)
		}

		ForceNewClusterFlagValue, err := cmd.Flags().GetBool(ForceNewClusterFlagName)
		if err != nil {
			return err, false
		}
		m.ForceNewCluster = ForceNewClusterFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmInitBodyListenAddrFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	ListenAddrFlagName := fmt.Sprintf("%v.ListenAddr", cmdPrefix)
	if cmd.Flags().Changed(ListenAddrFlagName) {

		var ListenAddrFlagName string
		if cmdPrefix == "" {
			ListenAddrFlagName = "ListenAddr"
		} else {
			ListenAddrFlagName = fmt.Sprintf("%v.ListenAddr", cmdPrefix)
		}

		ListenAddrFlagValue, err := cmd.Flags().GetString(ListenAddrFlagName)
		if err != nil {
			return err, false
		}
		m.ListenAddr = ListenAddrFlagValue

		retAdded = true
	}

	return nil, retAdded
}

func retrieveSwarmInitBodySpecFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	SpecFlagName := fmt.Sprintf("%v.Spec", cmdPrefix)
	if cmd.Flags().Changed(SpecFlagName) {
		// info: complex object Spec models.SwarmSpec is retrieved outside this Changed() block
	}
	SpecFlagValue := m.Spec
	if swag.IsZero(SpecFlagValue) {
		SpecFlagValue = &models.SwarmSpec{}
	}

	err, SpecAdded := retrieveModelSwarmSpecFlags(depth+1, SpecFlagValue, SpecFlagName, cmd)
	if err != nil {
		return err, false
	}
	retAdded = retAdded || SpecAdded
	if SpecAdded {
		m.Spec = SpecFlagValue
	}

	return nil, retAdded
}

func retrieveSwarmInitBodySubnetSizeFlags(depth int, m *swarm.SwarmInitBody, cmdPrefix string, cmd *cobra.Command) (error, bool) {
	if depth > maxDepth {
		return nil, false
	}
	retAdded := false

	SubnetSizeFlagName := fmt.Sprintf("%v.SubnetSize", cmdPrefix)
	if cmd.Flags().Changed(SubnetSizeFlagName) {

		// warning: primitive SubnetSize uint32 is not supported by go-swagger cli yet

		retAdded = true
	}

	return nil, retAdded
}
